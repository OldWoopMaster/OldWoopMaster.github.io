<html>
<head meta="charset="utf-8">
<title>Вопрос№4</title>
</head>
<style>
	dir {font-family:"Times New Roman"; font-size:18px;}
	li {font-family:"Times New Roman"; font-size:18px;}
	.ulist {list-style-type:circle;}
</style>
<body>
<h1 align="center">Ответ на Вопрос№4</h1>
<article>
<p style="font-size:30px;"><b>Вопрос 4. В чём заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?</b></p>
<section>
<dir>Преимущества:</dir>
	<ul>
		<li>Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.</li>
		<li>Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.</li>
		<li>Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. 
			Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.
		</li>
		<li>Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.</li>
		<li>Возможность создавать расширяемые системы.</li>
		<li>Использование полиморфизма оказывается полезным при: </li>
		<ul class="ulist">
			<li>Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.</li>
			<li>Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.</li>
			<li>Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.</li>
			<li>Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.</li>
		</ul>
		<li>Повторное использование кода: </li>
		<ul class="ulist">
			<li>Сокращается время на разработку, которое может быть отдано другим задачам.</li>
			<li>Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.</li>
			<li>Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.</li>
			<li>Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.</li>
		</ul>
	</ul>
<dir>Недостатки:</dir>
	<ul>
	<li>В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.</li>
	<li>Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).</li>
	<li>Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.</li>
	<li>Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).</li>
	<li>Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.</li>
	</ul>
</section>
</article>
</body>
</html>